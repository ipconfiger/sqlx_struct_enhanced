// Tests for aggregation query support
// Tests the new AggQueryBuilder for SUM, AVG, COUNT, MIN, MAX with GROUP BY

use sqlx_struct_enhanced::{EnhancedCrud, Scheme};
use sqlx::{FromRow, Postgres, query::Query, query::QueryAs};
use sqlx::database::HasArguments;
use sqlx::Row;

// Test struct for aggregation queries
#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct Order {
    id: String,
    category: String,
    amount: i32,
    status: String,
}

#[test]
fn test_agg_query_method_exists() {
    // Test that agg_query() method is generated by the derive macro
    let _builder = Order::agg_query();
    // If this compiles, the test passes
}

#[test]
fn test_simple_sum_aggregation() {
    let builder = Order::agg_query().sum("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT SUM(amount) FROM"));
    assert!(sql.contains("order"));  // Should contain table name "order"
}

#[test]
fn test_simple_avg_aggregation() {
    let builder = Order::agg_query().avg("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT AVG(amount) FROM"));
}

#[test]
fn test_count_aggregation() {
    let builder = Order::agg_query().count();
    let sql = builder.build();

    assert!(sql.contains("SELECT COUNT(*) FROM"));
}

#[test]
fn test_count_column_aggregation() {
    let builder = Order::agg_query().count_column("id");
    let sql = builder.build();

    assert!(sql.contains("SELECT COUNT(id) FROM"));
}

#[test]
fn test_min_aggregation() {
    let builder = Order::agg_query().min("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT MIN(amount) FROM"));
}

#[test]
fn test_max_aggregation() {
    let builder = Order::agg_query().max("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT MAX(amount) FROM"));
}

#[test]
fn test_group_by_with_sum() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_group_by_with_multiple_aggregates() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .avg("amount")
        .count();

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount), AVG(amount), COUNT(*)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_with_where_clause() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("SELECT SUM(amount)"));
}

#[test]
fn test_group_by_with_where() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("SELECT category, SUM(amount)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_chaining_order() {
    // The order of method calls should not matter for the final SQL
    let builder1 = Order::agg_query()
        .sum("amount")
        .group_by("category");

    let builder2 = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql1 = builder1.build();
    let sql2 = builder2.build();

    // Both should generate the same SQL
    assert_eq!(sql1, sql2);
}

#[test]
fn test_sql_caching() {
    // Build the same query twice and verify we get the same SQL string (same address)
    let builder1 = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql1 = builder1.build();
    let sql2 = builder1.build();

    // Should return the same cached string
    assert_eq!(sql1, sql2);
}

#[test]
fn test_min_max_aggregation() {
    let builder = Order::agg_query()
        .min("amount")
        .max("amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MIN(amount), MAX(amount) FROM"));
}

#[test]
fn test_complex_query() {
    // Test a complex query with WHERE, GROUP BY, and multiple aggregates
    let builder = Order::agg_query()
        .where_("status = {} AND amount > {}", &["active", "100"])
        .group_by("category")
        .sum("amount")
        .avg("amount")
        .count()
        .min("amount")
        .max("amount");

    let sql = builder.build();

    // Verify all components are present
    assert!(sql.contains("SELECT category, SUM(amount), AVG(amount), COUNT(*), MIN(amount), MAX(amount)"));
    assert!(sql.contains("WHERE status = $1 AND amount > $2"));
    assert!(sql.contains("GROUP BY category"));
}

// ============================================================================
// Phase 2 Tests: Custom Aliases
// ============================================================================

#[test]
fn test_sum_with_alias() {
    let builder = Order::agg_query()
        .sum_as("amount", "total_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT SUM(amount) AS total_amount"));
}

#[test]
fn test_avg_with_alias() {
    let builder = Order::agg_query()
        .avg_as("amount", "average_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT AVG(amount) AS average_amount"));
}

#[test]
fn test_count_with_alias() {
    let builder = Order::agg_query()
        .count_as("order_count");

    let sql = builder.build();
    assert!(sql.contains("SELECT COUNT(*) AS order_count"));
}

#[test]
fn test_count_column_with_alias() {
    let builder = Order::agg_query()
        .count_column_as("id", "id_count");

    let sql = builder.build();
    assert!(sql.contains("SELECT COUNT(id) AS id_count"));
}

#[test]
fn test_min_with_alias() {
    let builder = Order::agg_query()
        .min_as("amount", "min_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MIN(amount) AS min_amount"));
}

#[test]
fn test_max_with_alias() {
    let builder = Order::agg_query()
        .max_as("amount", "max_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MAX(amount) AS max_amount"));
}

#[test]
fn test_multiple_aggregates_with_custom_aliases() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .avg_as("amount", "average")
        .count_as("cnt")
        .min_as("amount", "minimum")
        .max_as("amount", "maximum");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount) AS average, COUNT(*) AS cnt, MIN(amount) AS minimum, MAX(amount) AS maximum"));
}

// ============================================================================
// Phase 2 Tests: HAVING Clause
// ============================================================================

#[test]
fn test_having_with_aggregate_function() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .having("SUM(amount) > {}", &[&1000i64]);

    let sql = builder.build();
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING SUM(amount) > $1"));
}

#[test]
fn test_having_with_alias() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&1000i64]);

    let sql = builder.build();
    assert!(sql.contains("HAVING total > $1"));
}

#[test]
fn test_where_group_by_having() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&500i64]);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));  // $2 because comes after WHERE
}

// ============================================================================
// Phase 2 Tests: ORDER BY
// ============================================================================

#[test]
fn test_order_by_asc() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .order_by("total", "ASC");

    let sql = builder.build();
    assert!(sql.contains("ORDER BY total ASC"));
}

#[test]
fn test_order_by_desc() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .order_by("total", "DESC");

    let sql = builder.build();
    assert!(sql.contains("ORDER BY total DESC"));
}

#[test]
fn test_order_by_case_insensitive() {
    let builder1 = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .order_by("category", "desc");

    let builder2 = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .order_by("category", "DESC");

    // Both should generate the same SQL
    assert_eq!(builder1.build(), builder2.build());
    assert!(builder1.build().contains("ORDER BY category DESC"));
}

#[test]
fn test_order_by_with_multiple_aggregates() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .avg("amount")
        .order_by("total", "DESC");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount)"));
    assert!(sql.contains("ORDER BY total DESC"));
}

// ============================================================================
// Phase 2 Tests: LIMIT
// ============================================================================

#[test]
fn test_limit() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .limit(10);

    let sql = builder.build();
    assert!(sql.contains("LIMIT $1"));
}

#[test]
fn test_limit_with_where() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum("amount")
        .limit(5);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("LIMIT $2"));
}

// ============================================================================
// Phase 2 Tests: OFFSET
// ============================================================================

#[test]
fn test_offset() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .offset(20);

    let sql = builder.build();
    assert!(sql.contains("OFFSET $1"));
}

#[test]
fn test_offset_with_limit() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .limit(10)
        .offset(20);

    let sql = builder.build();
    assert!(sql.contains("LIMIT $1"));
    assert!(sql.contains("OFFSET $2"));
}

// ============================================================================
// Phase 2 Tests: Complex Queries (All Features Combined)
// ============================================================================

#[test]
fn test_complete_complex_query() {
    // Test a query with all features: WHERE, GROUP BY, aggregates with aliases,
    // HAVING, ORDER BY, LIMIT
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .avg_as("amount", "average")
        .having("total > {}", &[&1000i64])
        .order_by("total", "DESC")
        .limit(10);

    let sql = builder.build();

    // Verify all components
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount) AS average"));
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));
    assert!(sql.contains("ORDER BY total DESC"));
    assert!(sql.contains("LIMIT $3"));
}

#[test]
fn test_pagination_with_all_features() {
    // Test pagination with OFFSET and all other features
    let builder = Order::agg_query()
        .where_("status = {} AND amount > {}", &["active", "100"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&500i64])
        .order_by("total", "DESC")
        .limit(10)
        .offset(20);

    let sql = builder.build();

    // Verify parameter numbering
    assert!(sql.contains("WHERE status = $1 AND amount > $2"));
    assert!(sql.contains("HAVING total > $3"));
    assert!(sql.contains("LIMIT $4"));
    assert!(sql.contains("OFFSET $5"));
}

#[test]
fn test_chaining_preserves_state() {
    // Test that method chaining preserves the builder state correctly
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&1000i64])
        .order_by("total", "DESC")
        .limit(10);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));
    assert!(sql.contains("ORDER BY total DESC"));
    assert!(sql.contains("LIMIT $3"));
}

// ============================================================================
// Integration Tests: New Fetch Methods
// ============================================================================

// Note: These tests require a running PostgreSQL database
// They should be run with: cargo test --features postgres -- --ignored

#[sqlx::test]
async fn test_fetch_count_simple(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_users_count (
            id VARCHAR PRIMARY KEY,
            role VARCHAR NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_users_count (id, role) VALUES ($1, $2)")
        .bind("user1")
        .bind("admin")
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_users_count (id, role) VALUES ($1, $2)")
        .bind("user2")
        .bind("admin")
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_users_count (id, role) VALUES ($1, $2)")
        .bind("user3")
        .bind("user")
        .execute(&pool)
        .await?;

    // Test fetch_count with specialized method
    let count = TestUsersCount::agg_query()
        .where_("role = {}", &[&"admin"])
        .count()
        .fetch_count(&pool)
        .await?;

    assert_eq!(count, 2);

    // Cleanup
    sqlx::query("DROP TABLE test_users_count")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_one_with_tuple(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_rating (
            id VARCHAR PRIMARY KEY,
            engineer_id VARCHAR NOT NULL,
            score DOUBLE PRECISION NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_rating (id, engineer_id, score) VALUES ($1, $2, $3)")
        .bind("rating1")
        .bind("eng1")
        .bind(5.0)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_rating (id, engineer_id, score) VALUES ($1, $2, $3)")
        .bind("rating2")
        .bind("eng1")
        .bind(4.0)
        .execute(&pool)
        .await?;

    // Test fetch_one with generic method (AVG + COUNT)
    let (avg, count): (Option<f64>, i64) = TestRating::agg_query()
        .where_("engineer_id = {}", &[&"eng1"])
        .avg("score")
        .count()
        .fetch_one(&pool)
        .await?;

    assert_eq!(count, 2);
    assert_eq!(avg, Some(4.5));

    // Cleanup
    sqlx::query("DROP TABLE test_rating")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_all_group_by(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_order_status (
            id VARCHAR PRIMARY KEY,
            status VARCHAR NOT NULL,
            amount INTEGER NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_order_status (id, status, amount) VALUES ($1, $2, $3)")
        .bind("order1")
        .bind("completed")
        .bind(100)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_order_status (id, status, amount) VALUES ($1, $2, $3)")
        .bind("order2")
        .bind("completed")
        .bind(200)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_order_status (id, status, amount) VALUES ($1, $2, $3)")
        .bind("order3")
        .bind("pending")
        .bind(150)
        .execute(&pool)
        .await?;

    // Test fetch_all with GROUP BY
    let results: Vec<(String, i64)> = TestOrderStatus::agg_query()
        .group_by("status")
        .count()
        .fetch_all(&pool)
        .await?;

    assert_eq!(results.len(), 2);
    assert!(results.iter().any(|(status, count)| status == "completed" && *count == 2));
    assert!(results.iter().any(|(status, count)| status == "pending" && *count == 1));

    // Cleanup
    sqlx::query("DROP TABLE test_order_status")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_optional(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_item (
            id VARCHAR PRIMARY KEY,
            value INTEGER NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_item (id, value) VALUES ($1, $2)")
        .bind("item1")
        .bind(42)
        .execute(&pool)
        .await?;

    // Test fetch_optional with existing data (use MIN which returns one row per group)
    let result: Option<(Option<i32>,)> = TestItem::agg_query()
        .where_("id = {}", &[&"item1"])
        .min("value")
        .fetch_optional(&pool)
        .await?;

    assert_eq!(result, Some((Some(42),)));

    // Test fetch_optional with non-existing data (MIN returns NULL when no rows match)
    let result: Option<(Option<i32>,)> = TestItem::agg_query()
        .where_("id = {}", &[&"nonexistent"])
        .min("value")
        .fetch_optional(&pool)
        .await?;

    // MIN with no matching rows still returns one row with NULL value
    assert_eq!(result, Some((None,)));

    // Cleanup
    sqlx::query("DROP TABLE test_item")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_avg_specialized(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_score (
            id VARCHAR PRIMARY KEY,
            score DOUBLE PRECISION NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_score (id, score) VALUES ($1, $2)")
        .bind("score1")
        .bind(10.0)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_score (id, score) VALUES ($1, $2)")
        .bind("score2")
        .bind(20.0)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_score (id, score) VALUES ($1, $2)")
        .bind("score3")
        .bind(30.0)
        .execute(&pool)
        .await?;

    // Test fetch_avg specialized method
    let avg = TestScore::agg_query()
        .avg("score")
        .fetch_avg(&pool)
        .await?;

    assert_eq!(avg, Some(20.0));

    // Cleanup
    sqlx::query("DROP TABLE test_score")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_sum_specialized(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_amount (
            id VARCHAR PRIMARY KEY,
            amount DOUBLE PRECISION NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    sqlx::query("INSERT INTO test_amount (id, amount) VALUES ($1, $2)")
        .bind("amt1")
        .bind(100.0)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_amount (id, amount) VALUES ($1, $2)")
        .bind("amt2")
        .bind(200.0)
        .execute(&pool)
        .await?;

    sqlx::query("INSERT INTO test_amount (id, amount) VALUES ($1, $2)")
        .bind("amt3")
        .bind(300.0)
        .execute(&pool)
        .await?;

    // Test fetch_sum specialized method
    let sum = TestAmount::agg_query()
        .sum("amount")
        .fetch_sum(&pool)
        .await?;

    assert_eq!(sum, Some(600.0));

    // Cleanup
    sqlx::query("DROP TABLE test_amount")
        .execute(&pool)
        .await?;

    Ok(())
}

#[sqlx::test]
async fn test_fetch_with_limit_offset(pool: sqlx::PgPool) -> Result<(), sqlx::Error> {
    // Create test table
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS test_pagination (
            id VARCHAR PRIMARY KEY,
            category VARCHAR NOT NULL
        )"
    )
    .execute(&pool)
    .await?;

    // Insert test data
    for i in 1..=10 {
        sqlx::query("INSERT INTO test_pagination (id, category) VALUES ($1, $2)")
            .bind(format!("item{}", i))
            .bind(if i <= 5 { "A" } else { "B" })
            .execute(&pool)
            .await?;
    }

    // Test fetch_all with LIMIT
    let results: Vec<(String, i64)> = TestPagination::agg_query()
        .group_by("category")
        .count()
        .order_by("category", "DESC")
        .limit(1)
        .fetch_all(&pool)
        .await?;

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].0, "B");  // Should get category B first (DESC order)

    // Test fetch_all with OFFSET
    let results: Vec<(String, i64)> = TestPagination::agg_query()
        .group_by("category")
        .count()
        .order_by("category", "ASC")
        .limit(1)
        .offset(1)
        .fetch_all(&pool)
        .await?;

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].0, "B");  // Should skip A and get B

    // Cleanup
    sqlx::query("DROP TABLE test_pagination")
        .execute(&pool)
        .await?;

    Ok(())
}

// ============================================================================
// Test Models for Integration Tests
// ============================================================================

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestUsersCount {
    id: String,
    role: String,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestRating {
    id: String,
    engineer_id: String,
    score: i32,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestOrderStatus {
    id: String,
    status: String,
    amount: i32,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestItem {
    id: String,
    value: i32,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestScore {
    id: String,
    score: i32,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestAmount {
    id: String,
    amount: i32,
}

#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct TestPagination {
    id: String,
    category: String,
}

