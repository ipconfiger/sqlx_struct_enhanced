// Tests for aggregation query support
// Tests the new AggQueryBuilder for SUM, AVG, COUNT, MIN, MAX with GROUP BY

use sqlx_struct_enhanced::{EnhancedCrud, Scheme};
use sqlx::{FromRow, Postgres, query::Query, query::QueryAs};
use sqlx::database::HasArguments;

// Test struct for aggregation queries
#[derive(Debug, Clone, PartialEq, FromRow, EnhancedCrud)]
struct Order {
    id: String,
    category: String,
    amount: i32,
    status: String,
}

#[test]
fn test_agg_query_method_exists() {
    // Test that agg_query() method is generated by the derive macro
    let _builder = Order::agg_query();
    // If this compiles, the test passes
}

#[test]
fn test_simple_sum_aggregation() {
    let builder = Order::agg_query().sum("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT SUM(amount) FROM"));
    assert!(sql.contains("order"));  // Should contain table name "order"
}

#[test]
fn test_simple_avg_aggregation() {
    let builder = Order::agg_query().avg("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT AVG(amount) FROM"));
}

#[test]
fn test_count_aggregation() {
    let builder = Order::agg_query().count();
    let sql = builder.build();

    assert!(sql.contains("SELECT COUNT(*) FROM"));
}

#[test]
fn test_count_column_aggregation() {
    let builder = Order::agg_query().count_column("id");
    let sql = builder.build();

    assert!(sql.contains("SELECT COUNT(id) FROM"));
}

#[test]
fn test_min_aggregation() {
    let builder = Order::agg_query().min("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT MIN(amount) FROM"));
}

#[test]
fn test_max_aggregation() {
    let builder = Order::agg_query().max("amount");
    let sql = builder.build();

    assert!(sql.contains("SELECT MAX(amount) FROM"));
}

#[test]
fn test_group_by_with_sum() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_group_by_with_multiple_aggregates() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .avg("amount")
        .count();

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount), AVG(amount), COUNT(*)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_with_where_clause() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("SELECT SUM(amount)"));
}

#[test]
fn test_group_by_with_where() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum("amount");

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("SELECT category, SUM(amount)"));
    assert!(sql.contains("GROUP BY category"));
}

#[test]
fn test_chaining_order() {
    // The order of method calls should not matter for the final SQL
    let builder1 = Order::agg_query()
        .sum("amount")
        .group_by("category");

    let builder2 = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql1 = builder1.build();
    let sql2 = builder2.build();

    // Both should generate the same SQL
    assert_eq!(sql1, sql2);
}

#[test]
fn test_sql_caching() {
    // Build the same query twice and verify we get the same SQL string (same address)
    let builder1 = Order::agg_query()
        .group_by("category")
        .sum("amount");

    let sql1 = builder1.build();
    let sql2 = builder1.build();

    // Should return the same cached string
    assert_eq!(sql1, sql2);
}

#[test]
fn test_min_max_aggregation() {
    let builder = Order::agg_query()
        .min("amount")
        .max("amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MIN(amount), MAX(amount) FROM"));
}

#[test]
fn test_complex_query() {
    // Test a complex query with WHERE, GROUP BY, and multiple aggregates
    let builder = Order::agg_query()
        .where_("status = {} AND amount > {}", &["active", "100"])
        .group_by("category")
        .sum("amount")
        .avg("amount")
        .count()
        .min("amount")
        .max("amount");

    let sql = builder.build();

    // Verify all components are present
    assert!(sql.contains("SELECT category, SUM(amount), AVG(amount), COUNT(*), MIN(amount), MAX(amount)"));
    assert!(sql.contains("WHERE status = $1 AND amount > $2"));
    assert!(sql.contains("GROUP BY category"));
}

// ============================================================================
// Phase 2 Tests: Custom Aliases
// ============================================================================

#[test]
fn test_sum_with_alias() {
    let builder = Order::agg_query()
        .sum_as("amount", "total_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT SUM(amount) AS total_amount"));
}

#[test]
fn test_avg_with_alias() {
    let builder = Order::agg_query()
        .avg_as("amount", "average_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT AVG(amount) AS average_amount"));
}

#[test]
fn test_count_with_alias() {
    let builder = Order::agg_query()
        .count_as("order_count");

    let sql = builder.build();
    assert!(sql.contains("SELECT COUNT(*) AS order_count"));
}

#[test]
fn test_count_column_with_alias() {
    let builder = Order::agg_query()
        .count_column_as("id", "id_count");

    let sql = builder.build();
    assert!(sql.contains("SELECT COUNT(id) AS id_count"));
}

#[test]
fn test_min_with_alias() {
    let builder = Order::agg_query()
        .min_as("amount", "min_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MIN(amount) AS min_amount"));
}

#[test]
fn test_max_with_alias() {
    let builder = Order::agg_query()
        .max_as("amount", "max_amount");

    let sql = builder.build();
    assert!(sql.contains("SELECT MAX(amount) AS max_amount"));
}

#[test]
fn test_multiple_aggregates_with_custom_aliases() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .avg_as("amount", "average")
        .count_as("cnt")
        .min_as("amount", "minimum")
        .max_as("amount", "maximum");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount) AS average, COUNT(*) AS cnt, MIN(amount) AS minimum, MAX(amount) AS maximum"));
}

// ============================================================================
// Phase 2 Tests: HAVING Clause
// ============================================================================

#[test]
fn test_having_with_aggregate_function() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .having("SUM(amount) > {}", &[&1000i64]);

    let sql = builder.build();
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING SUM(amount) > $1"));
}

#[test]
fn test_having_with_alias() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&1000i64]);

    let sql = builder.build();
    assert!(sql.contains("HAVING total > $1"));
}

#[test]
fn test_where_group_by_having() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&500i64]);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));  // $2 because comes after WHERE
}

// ============================================================================
// Phase 2 Tests: ORDER BY
// ============================================================================

#[test]
fn test_order_by_asc() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .order_by("total", "ASC");

    let sql = builder.build();
    assert!(sql.contains("ORDER BY total ASC"));
}

#[test]
fn test_order_by_desc() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .order_by("total", "DESC");

    let sql = builder.build();
    assert!(sql.contains("ORDER BY total DESC"));
}

#[test]
fn test_order_by_case_insensitive() {
    let builder1 = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .order_by("category", "desc");

    let builder2 = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .order_by("category", "DESC");

    // Both should generate the same SQL
    assert_eq!(builder1.build(), builder2.build());
    assert!(builder1.build().contains("ORDER BY category DESC"));
}

#[test]
fn test_order_by_with_multiple_aggregates() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum_as("amount", "total")
        .avg("amount")
        .order_by("total", "DESC");

    let sql = builder.build();
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount)"));
    assert!(sql.contains("ORDER BY total DESC"));
}

// ============================================================================
// Phase 2 Tests: LIMIT
// ============================================================================

#[test]
fn test_limit() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .limit(10);

    let sql = builder.build();
    assert!(sql.contains("LIMIT $1"));
}

#[test]
fn test_limit_with_where() {
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum("amount")
        .limit(5);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("LIMIT $2"));
}

// ============================================================================
// Phase 2 Tests: OFFSET
// ============================================================================

#[test]
fn test_offset() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .offset(20);

    let sql = builder.build();
    assert!(sql.contains("OFFSET $1"));
}

#[test]
fn test_offset_with_limit() {
    let builder = Order::agg_query()
        .group_by("category")
        .sum("amount")
        .limit(10)
        .offset(20);

    let sql = builder.build();
    assert!(sql.contains("LIMIT $1"));
    assert!(sql.contains("OFFSET $2"));
}

// ============================================================================
// Phase 2 Tests: Complex Queries (All Features Combined)
// ============================================================================

#[test]
fn test_complete_complex_query() {
    // Test a query with all features: WHERE, GROUP BY, aggregates with aliases,
    // HAVING, ORDER BY, LIMIT
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .avg_as("amount", "average")
        .having("total > {}", &[&1000i64])
        .order_by("total", "DESC")
        .limit(10);

    let sql = builder.build();

    // Verify all components
    assert!(sql.contains("SELECT category, SUM(amount) AS total, AVG(amount) AS average"));
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));
    assert!(sql.contains("ORDER BY total DESC"));
    assert!(sql.contains("LIMIT $3"));
}

#[test]
fn test_pagination_with_all_features() {
    // Test pagination with OFFSET and all other features
    let builder = Order::agg_query()
        .where_("status = {} AND amount > {}", &["active", "100"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&500i64])
        .order_by("total", "DESC")
        .limit(10)
        .offset(20);

    let sql = builder.build();

    // Verify parameter numbering
    assert!(sql.contains("WHERE status = $1 AND amount > $2"));
    assert!(sql.contains("HAVING total > $3"));
    assert!(sql.contains("LIMIT $4"));
    assert!(sql.contains("OFFSET $5"));
}

#[test]
fn test_chaining_preserves_state() {
    // Test that method chaining preserves the builder state correctly
    let builder = Order::agg_query()
        .where_("status = {}", &["active"])
        .group_by("category")
        .sum_as("amount", "total")
        .having("total > {}", &[&1000i64])
        .order_by("total", "DESC")
        .limit(10);

    let sql = builder.build();
    assert!(sql.contains("WHERE status = $1"));
    assert!(sql.contains("GROUP BY category"));
    assert!(sql.contains("HAVING total > $2"));
    assert!(sql.contains("ORDER BY total DESC"));
    assert!(sql.contains("LIMIT $3"));
}

